<!DOCTYPE HTML>
<html lang="en"><!--G04#013 - Carmela - Connect Four-->
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title id="title">Connect Four</title>
		<style>
			body{
				text-align: center;
				font-family: sans-serif;
				transition: background 0.5s;
				padding: 10px;
				-webkit-tap-highlight-color: transparent;
			}
			canvas{
				cursor: pointer;
				margin-top: 10px;
				border-radius: 8px;
				box-shadow: 0 4px 15px rgba(0,0,0,0.3);
				max-width: 100%;
				height: auto;
			}
			button, select{
				margin: 5px;
				padding: 10px 15px;
				cursor: pointer;
				font-weight: bold;
				border-radius: 5px;
				border: 1px solid #999;
				background: #eee;
			}
			button:hover, select:hover{
				background-color: #ddd;
			}
			#starter{
				margin-top: 10px;
				padding: 10px;
				background: rgba(255,255,255,0.4);
				display: inline-block;
				border-radius: 10px;
			}
		</style>
	</head>
	<body>
		<canvas id="board">Upgrade Browser</canvas>
		<div class="controls">
			<div>
				<button type="button" id="hintButton" onclick="giveHint()">Hint</button>
				<button type="button" id="undoButton" onclick="undoLastMove()">Undo</button>
				<button type="button" id="restartButton" onclick="refresh()">Start again!</button>
			</div>
			<div>
				<button type="button" id="difficultyButton" onclick="cycleDifficulty()">Medium</button>
				<button type="button" id="changeLanguageButton" onclick="cycleLanguage()">Language</button>
			</div>
			<div id="starter">
				<label id="starterText">Starter: </label>
				<input type="radio" id="Yellow" name="beginner" checked onclick="setStarter(true)">
				<label id="YellowLabel" for="Yellow">Yellow</label>
				<input type="radio" id="Red" name="beginner" onclick="setStarter(false)">
				<label id="RedLabel" for="Red">Red</label>
			</div>
		</div>

		<script>
			const DESKTOP = !(/Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i).test(navigator.userAgent);
			const UNIT = DESKTOP ? 10 : 5;
			const RADIUS = 4*UNIT;
			const DIAMETER = 2*RADIUS;
			const GRID_THICKNESS = UNIT;
			const ROW_NUMBER = 6;
			const COLUMN_NUMBER = 7;
			const DEPTH = 5;
			const BLUE_COLOR = "#0033FF";
			const YELLOW_COLOR = "#FFFF33";
			const RED_COLOR = "#FF0033";
			const LIGHT_ORANGE_COLOR = "#FFCC33";
			const WHITE = "#FFFFFF";
			const TITLES = ["Connect four", "Forza 4", "Connecter Quatre", "Conecta 4", "Vier Gewinnt", "Conecta 4", "Conecta patru", "Чотири в ряд", "Συνδέστε τέσσερα", "Conecta quattuor", "四子连珠", "四目並べ"];
			const RESTART_LABELS = ["Start again!", "Ricomincia", "Recommencer", "¡Empezar de nuovo!", "Erneut starten!", "Recomeçar", "Începe din nou", "Почати заново", "Ξεκινήστε ξανά", "Iterum incipere", "重新开始", "再スタート"];
			const LANGUAGES_LABELS = ["English", "Italiano", "Française", "Español", "Deutsch", "Português", "Română", "Українська", "Ελληνικά", "Latine", "中文", "日本語"];
			const UNDO_LABELS = ["Undo", "Annulla", "Annuler", "Anula", "Abbrechen", "Desfazer", "Anulează", "Скасувати", "Αναίρεση", "Annula", "撤销", "元に戻す"];
			const BEGINNING_LABELS = ["Starter: ", "Inizia: ", "Commencer: ", "Comenzar: ", "Anfang: ", "Começar: ", "Începe :", "Почати: ", "Αρχή: ", "Incipit: ", "开始: ", "開始: "];
			const YELLOW_LABEL = ["Yellow", "Giallo", "Jaune", "Amarillo", "Gelb", "Amarelo", "Galben", "Жовтий", "Κίτρινο", "Flavus", "黄色", "黄色"];
			const RED_LABEL = ["Red", "Rosso", "Rouge", "Rojo", "Rot", "Vermelho", "Roșu", "Червоний", "Κόкκινο", "Ruber", "红色", "赤"];
			const WINNING_MESSAGE = ["The winner is: ", "Vince: ", "Le gagnant est: ", "El ganador es: ", "Der Gewinner ist: ", "O vencedor è: ", "Câștigătorul este: ", "Переможець: ", "Ο νικητής è: ", "Victor est: ", "获胜者是: ", "勝者は: "];
			const EASY_LABELS = ["Easy", "Facile", "Facile", "Fácil", "Einfach", "Fácil", "Ușor", "Легко", "Εύκολο", "Facilis", "简单", "簡単"];
			const MEDIUM_LABELS = ["Medium", "Medio", "Moyen", "Medio", "Mittel", "Médio", "Mediu", "Середній", "Μέτριο", "Medium", "中等", "中級"];
			const HARD_LABELS = ["Hard", "Difficile", "Difficile", "Difícil", "Schwer", "Difícil", "Greu", "Важко", "Δύσκολο", "Difficilis", "困难", "上級"];
			const HINT_LABELS = ["Hint", "Suggerimento", "Conseil", "Sugerencia", "Hinweis", "Sugestão", "Sugestie", "Підказка", "Υπόδειξη", "Consilium", "提示", "ヒント"];
			let difficultyIndex = 1;
			let grid = [];
			let moves = [];
			let moveYellow = true;
			let numberOfMoves = 0;
			let languageIndex = 0; 
			let goOn = true;
			let canvas, ctx, blinkInterval;
			let winningCells = [];
			let humanIsYellow = true;

			window.onload = function(){
				canvas = document.getElementById("board");
				ctx = canvas.getContext("2d");
				canvas.addEventListener("click", select);
				updateLabels(); 
				drawUniverse();
			};

			function playClackSound(){
				try{
					const audioCtx = new(window.AudioContext || window.webkitAudioContext)();
					const oscillator = audioCtx.createOscillator();
					const gainNode = audioCtx.createGain();
					oscillator.type = 'triangle';
					oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
					oscillator.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
					gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
					gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
					oscillator.connect(gainNode);
					gainNode.connect(audioCtx.destination);
					oscillator.start();
					oscillator.stop(audioCtx.currentTime + 0.1);
				}catch(e){}
			}

			function setStarter(isYellow){
				if(numberOfMoves === 0){
					moveYellow = isYellow;
					humanIsYellow = isYellow;
				}
			}

			function drawCircle(row, column, color){
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.arc((column + 1)*GRID_THICKNESS + column*DIAMETER + RADIUS, (row + 1)*GRID_THICKNESS + row*DIAMETER + RADIUS, RADIUS, 0, 2*Math.PI);
				ctx.fill();
			}

			function drawUniverse(){
				clearInterval(blinkInterval);
				document.body.style.background = LIGHT_ORANGE_COLOR;
				grid = Array.from({length: ROW_NUMBER },() => Array(COLUMN_NUMBER).fill(-1));
				moves = [];
				winningCells = [];
				numberOfMoves = 0;
				goOn = true;
				moveYellow = document.getElementById("Yellow").checked;
				humanIsYellow = moveYellow; 
				canvas.width = COLUMN_NUMBER*DIAMETER + GRID_THICKNESS*(COLUMN_NUMBER + 1);
				canvas.height = ROW_NUMBER*DIAMETER + GRID_THICKNESS*(ROW_NUMBER + 1);
				ctx.fillStyle = BLUE_COLOR;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				for(let r = 0; r < ROW_NUMBER; r++){
					for(let c = 0; c < COLUMN_NUMBER; c++){
						drawCircle(r, c, WHITE);
					}
				}
				document.getElementById('starter').style.visibility = "visible";
				if(numberOfMoves === 0 && moveYellow !== humanIsYellow){
					setTimeout(computerMove, 600);
				}
			}

			function computerMove() {
				if(!goOn){
					return;
				}
				const difficulty = difficultyIndex.toString();
				let chosenColumn = -1;
				if(difficulty === "0"){
					let validCols = [];
					for(let c = 0; c < COLUMN_NUMBER; c++){
						if(grid[0][c] === -1){
							validCols.push(c);
						}
					}
					chosenColumn = validCols[Math.floor(Math.random()*validCols.length)];
				}else if(difficulty === "1"){
					let bestScore = -Infinity;
					for(let c = 0; c < COLUMN_NUMBER; c++){
						let r = getAvailableRow(c);
						if(r !== -1){
							grid[r][c] = 1;
							let score = evaluateMoveMedium(r, c);
							grid[r][c] = -1;
							if(score > bestScore){
								bestScore = score;
								chosenColumn = c;
							}
						}
					}
				}else{
					let bestScore = -Infinity;
					for(let c = 0; c < COLUMN_NUMBER; c++) {
						let r = getAvailableRow(c);
						if(r !== -1){
							grid[r][c] = 1;
							let score = minimax(grid, DEPTH, false, -Infinity, Infinity);
							grid[r][c] = -1;
							if(score > bestScore){
								bestScore = score;
								chosenColumn = c;
							}
						}
					}
				}
				if(chosenColumn !== -1){
					const rect = canvas.getBoundingClientRect();
					const fakeEvent = { clientX: rect.left + (chosenColumn*(DIAMETER + GRID_THICKNESS)) + RADIUS + GRID_THICKNESS };
					select(fakeEvent);
				}
			}

			function evaluateMoveMedium(row, col){
				let score = 0;
				if(check(row, col)){
					return 10000;
				}
				grid[row][col] = 0; 
				if(check(row, col)){
					grid[row][col] = 1;
					return 5000;
				}
				grid[row][col] = 1;
				score += (3 - Math.abs(col - 3))*10;
				return score;
			}

			function minimax(board, depth, isMaximizing, alpha, beta) {
				let result = checkBoardHard();
				if(result === 1){
					return 10000 + depth;
				}
				if(result === 0){
					return -10000 - depth;
				}
				if(depth === 0 || moves.length === ROW_NUMBER*COLUMN_NUMBER){
					return evaluateBoardHard();
				}
				if(isMaximizing) {
					let maxEval = -Infinity;
					for(let c = 0; c < COLUMN_NUMBER; c++){
						let r = getAvailableRow(c);
						if(r !== -1) {
							board[r][c] = 1;
							let ev = minimax(board, depth - 1, false, alpha, beta);
							board[r][c] = -1;
							maxEval = Math.max(maxEval, ev);
							alpha = Math.max(alpha, ev);
							if(beta <= alpha){
								break;
							}
						}
					}
					return maxEval;
				}else{
					let minEval = Infinity;
					for(let c = 0; c < COLUMN_NUMBER; c++){
						let r = getAvailableRow(c);
						if(r !== -1){
							board[r][c] = 0;
							let ev = minimax(board, depth - 1, true, alpha, beta);
							board[r][c] = -1;
							minEval = Math.min(minEval, ev);
							beta = Math.min(beta, ev);
							if(beta <= alpha){
								break;
							}
						}
					}
					return minEval;
				}
			}

			function evaluateBoardHard() {
				let score = 0;
				for(let r = 0; r < ROW_NUMBER; r++) {
					if(grid[r][3] === 1){
						score += 3;
					}
					if(grid[r][3] === 0){
						score -= 3;
					}
				}
				return score;
			}

			function checkBoardHard() {
				for(let r = 0; r < ROW_NUMBER; r++) {
					for(let c = 0; c < COLUMN_NUMBER; c++) {
						if(grid[r][c] !== -1 && check(r, c)){
							return grid[r][c];
						}
					}
				}
				return -1;
			}

			function getAvailableRow(col) {
				for(let r = ROW_NUMBER - 1; r >= 0; r--){
					if(grid[r][col] === -1){
						return r;
					}
				}
				return -1;
			}

			function select(e){
				if(!goOn){
					return;
				}
				const rect = canvas.getBoundingClientRect();
				const scaleX = canvas.width/rect.width; 
				const x = (e.clientX - rect.left)*scaleX;
				const column = Math.floor(x/(DIAMETER + GRID_THICKNESS));
				if(column < 0 || column >= COLUMN_NUMBER){
					return;
				}
				let row = getAvailableRow(column);
				if(row >= 0){
					grid[row][column] = moveYellow ? 0 : 1;
					drawCircle(row, column, moveYellow ? YELLOW_COLOR : RED_COLOR);
					playClackSound();
					moves.push({r: row, c: column });
					numberOfMoves++;
					document.getElementById('starter').style.visibility = "hidden";
					let win = check(row, column);
					if(win){
						goOn = false;
						winningCells = win;
						startBlinking(moveYellow ? YELLOW_COLOR : RED_COLOR);
						const winner = moveYellow ? YELLOW_LABEL[languageIndex] : RED_LABEL[languageIndex];
						document.body.style.background = moveYellow ? "#FFFFCC" : "#FFCCCC";
						setTimeout(() => alert(WINNING_MESSAGE[languageIndex] + winner + "!"), 100);
					}
					if(goOn){
						moveYellow = !moveYellow;
						if(moveYellow !== humanIsYellow){
							canvas.style.pointerEvents = "none";
							setTimeout(() => {
								computerMove();
								canvas.style.pointerEvents = "auto";
							}, 600);
						}
					}
				}
			}

			function check(row, col){
				const current = grid[row][col];
				const directions = [[[0,1],[0,-1]], [[1,0],[-1,0]], [[1,1],[-1,-1]], [[1,-1],[-1,1]]];
				for(let d of directions){
					let cells = [{r: row, c: col}];
					for(let [dr, dc] of d){
						let r = row + dr, c = col + dc;
						while(r >= 0 && r < ROW_NUMBER && c >= 0 && c < COLUMN_NUMBER && grid[r][c] === current){
							cells.push({r: r, c: c});
							r += dr; c += dc;
						}
					}
					if(cells.length >= 4){
						return cells;
					}
				}
				return null;
			}

			function startBlinking(color){
				let isOn = true;
				blinkInterval = setInterval(() => {
					winningCells.forEach(cell => drawCircle(cell.r, cell.c, isOn ? WHITE : color));
					isOn = !isOn;
				}, 400);
			}

			function cycleLanguage(){
				languageIndex = (languageIndex + 1)%TITLES.length;
				updateLabels();
			}

			function cycleDifficulty() {
				difficultyIndex = (difficultyIndex + 1)%3;
				updateLabels();
			}

			function updateLabels(){
				document.getElementById("title").textContent = TITLES[languageIndex];
				document.title = TITLES[languageIndex];
				document.getElementById("restartButton").textContent = RESTART_LABELS[languageIndex];
				document.getElementById("changeLanguageButton").textContent = LANGUAGES_LABELS[languageIndex];
				document.getElementById("undoButton").textContent = UNDO_LABELS[languageIndex];
				document.getElementById("starterText").textContent = BEGINNING_LABELS[languageIndex];
				document.getElementById("YellowLabel").textContent = YELLOW_LABEL[languageIndex];
				document.getElementById("RedLabel").textContent = RED_LABEL[languageIndex];
				document.getElementById("hintButton").textContent = HINT_LABELS[languageIndex];
				const diffTexts = [EASY_LABELS, MEDIUM_LABELS, HARD_LABELS];
				document.getElementById("difficultyButton").textContent = diffTexts[difficultyIndex][languageIndex];
			}

			function undoLastMove(){
				for(let i = 0; i < 2; i++) {
					if(moves.length > 0){
						let last = moves.pop();
						grid[last.r][last.c] = -1;
						drawCircle(last.r, last.c, WHITE);
						numberOfMoves--;
						moveYellow = !moveYellow;
						goOn = true;
					}
				}
				if(numberOfMoves === 0){
					document.getElementById('starter').style.visibility = "visible";
				}
			}

			function giveHint() {
				if(!goOn || !moveYellow){
					return;
				}
				let bestScore = -Infinity;
				let hintCol = -1;
				for(let c = 0; c < COLUMN_NUMBER; c++) {
					let r = getAvailableRow(c);
					if(r !== -1){
						grid[r][c] = 0;
						let score = minimax(grid, DEPTH, true, -Infinity, Infinity);
						grid[r][c] = -1;
						if(score > bestScore){
							bestScore = score;
							hintCol = c;
						}
					}
				}
				if(hintCol !== -1){
					let r = getAvailableRow(hintCol);
					let originalColor = WHITE;
					let count = 0;
					let interval = setInterval(() => {
						drawCircle(r, hintCol, count%2 === 0 ? "#AAFFAA" : WHITE);
						if(++count > 5){
							clearInterval(interval);
							drawCircle(r, hintCol, WHITE);
						}
					}, 200);
				}
			}

			function refresh(){
				drawUniverse();
			}
		</script>
	</body>
</html>