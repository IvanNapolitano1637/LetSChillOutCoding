<!DOCTYPE html><!--DA AGGIUSTARE, CONTROLLARE E SISTEMARE-->
<!--CI SONO REGRESSIONI. HO IL CODICE NUOVO MA NON HO IL TEMPO DI SISTEMARLO E CONTROLLARLO ORA-->
<html lang="en"><!--G07#019 - Filippo - Chess-->
	<head>
		<meta charset="UTF-8">
		<title>Chess</title>
		<style>
			:root{
				--bg: #2c3e50;
				--light: #f0d9b5;
				--dark: #b58863;
				--sel: #769656;
				--last-move: rgba(255, 255, 0, 0.4);
				--capture-flash: #e74c3c;
			}
			body{
				font-family: 'Segoe UI', sans-serif;
				background: var(--bg);
				color: white;
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 20px;
			}
			.main-container{
				display: flex;
				gap: 20px;
				flex-wrap: wrap;
				justify-content: center;
			}
			.board{
				display: grid;
				grid-template-columns: repeat(8, 60px);
				grid-template-rows: repeat(8, 60px);
				border: 8px solid #34495e;
				box-shadow: 0 10px 30px rgba(0,0,0,0.5);
			}
			.square{
				width: 60px;
				height: 60px;
				display: flex;
				justify-content: center;
				align-items: center;
				font-size: 45px;
				cursor: pointer;
				user-select: none;
				position: relative;
				transition: background 0.2s;
			}
			.light{
				background-color: var(--light);
			}
			.dark{
				background-color: var(--dark);
			}
			.selected{
				background-color: var(--sel) !important;
			}
			.last-move{
				background-color: var(--last-move) !important;
			}
			.in-check{
				background-color: #e74c3c !important;
			}
			.legal-dot::after{
				content: '';
				width: 20px;
				height: 20px;
				background-color: #27ae60;
				border-radius: 50%;
				position: absolute;
				opacity: 0.8;
			}
			.capture-mark{
				background-color: rgba(39, 174, 96, 0.4) !important;
				border: 4px solid #27ae60;
				box-sizing: border-box;
			}
			.game-layout{
				display: flex;
				gap: 20px;
				align-items: flex-start;
				margin-top: 10px;
			}
			.info-panel{
				width: 250px;
				height: 496px;
				background: #34495e;
				padding: 15px;
				border-radius: 8px;
				text-align: left;
				overflow-y: auto;
				box-sizing: border-box;
				display: none;
			}
			.status{
				font-size: 1.2rem;
				margin-bottom: 15px;
				color: #f1c40f;
				font-weight: bold;
			}
			.log-entry{
				font-size: 0.9rem;
				border-bottom: 1px solid #456789;
				padding: 5px 0;
				color: #ecf0f1;
			}
			button{
				margin-top: 20px;
				padding: 10px 20px;
				cursor: pointer;
				background: #27ae60;
				color: white;
				border: none;
				border-radius: 5px;
			}
		</style>
	</head>
	<body>
		<h1>Chess</h1>
		<div id = "status" class = "status">White to move.</div>
		<div style = "margin-bottom: 15px;">
			<input type = "checkbox" id = "toggleLog" onclick = "toggleLog()">
			<label for = "toggleLog" style = "cursor:pointer; font-size: 0.9rem;">Show Log Moves</label>
		</div>
		<div class = "game-layout">
			<div id = "board" class = "board"></div>
			<div class = "info-panel" id = "logContainer">
				<div style = "font-weight: bold; border-bottom: 2px solid #f1c40f; margin-bottom: 10px;">LOG MOVES</div>
				<div id = "moveLog"></div>
			</div>
		</div>
		<button onclick = "location.reload()">Reset Game</button>

		<script>
			let board = [
				['r','n','b','q','k','b','n','r'], ['p','p','p','p','p','p','p','p'],
				['','','','','','','',''], ['','','','','','','',''],
				['','','','','','','',''], ['','','','','','','',''],
				['P','P','P','P','P','P','P','P'], ['R','N','B','Q','K','B','N','R']
			];
			let moved = {'K': false, 'R_7_0': false, 'R_7_7': false, 'k': false, 'r_0_0': false, 'r_0_7': false};
			const piecesNames = {'P':'Pawn', 'R':'Rook', 'N':'Knight', 'B':'Bishop', 'Q':'Queen', 'K':'King', 'p':'Pawn', 'r':'Rook', 'n':'Knight', 'b':'Bishop', 'q':'Queen', 'k':'King'};
			const pieces = {'p':'♟', 'r':'♜', 'n':'♞', 'b':'♝', 'q':'♛', 'k':'♚', 'P':'♙', 'R':'♖', 'N':'♘', 'B':'♗', 'Q':'♕', 'K':'♔'};
			let selected = null, legalMoves = [], turn = 'W', lastMove = null;

			function drawBoard(){
				const boardEl = document.getElementById('board');
				boardEl.innerHTML = '';
				const kingPos = findKing(board, turn);
				const inCheck = isSquareAttacked(board, kingPos.r, kingPos.c, turn === 'W' ? 'B' : 'W');
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const sq = document.createElement('div');
						sq.className = `square ${(r + c)%2 === 0 ? 'light' : 'dark'}`;
						const p = board[r][c];
						if(p){
							sq.textContent = pieces[p];
							sq.style.color = p === p.toUpperCase() ? "white" : "black";
							if(p === p.toUpperCase()){
								sq.style.textShadow = "0 0 3px black";
							}
						}
						if(lastMove && ((lastMove.fR === r && lastMove.fC === c) || (lastMove.tR === r && lastMove.tC === c))){
							sq.classList.add('last-move');
						}
						if(selected && selected.r === r && selected.c === c){
							sq.classList.add('selected');
						}
						if(p && p.toUpperCase() === 'K' && ((p === 'K' && turn === 'W' && inCheck) || (p === 'k' && turn === 'B' && inCheck))){
							sq.classList.add('in-check');
						}
						const move = legalMoves.find(m => m.r === r && m.c === c);
						if(move){
							if(board[r][c]){
								sq.classList.add('capture-mark');
							}else{
								sq.classList.add('legal-dot');
							}
						}
						sq.onclick = () => handleClick(r, c);
						boardEl.appendChild(sq);
					}
				}
			}

			function findKing(b, color){
				const target = color === 'W' ? 'K' : 'k';
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						if(b[r][c] === target){
							return {r, c};
						}
					}
				}
			}

			function isSquareAttacked(b, row, col, attackerColor){
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const p = b[r][c];
						if(!p || (attackerColor === 'W' ? p !== p.toUpperCase() : p !== p.toLowerCase())){
							continue;
						}
						if(getRawMoves(b, r, c, false).some(m => m.r === row && m.c === col)){
							return true;
						}
					}
				}
				return false;
			}

			function getRawMoves(b, r, c, includeCastling = true){
				let m = [];
				const p = b[r][c].toLowerCase();
				const isW = b[r][c] === b[r][c].toUpperCase();
				const dirs ={'r': [[1,0],[-1,0],[0,1],[0,-1]], 'b': [[1,1],[1,-1],[-1,1],[-1,-1]], 'q': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], 'n': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]], 'k': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]};
				if(p === 'p'){
					let d = isW ? -1 : 1;
					if(r + d >= 0 && r + d < 8 && !b[r + d][c]){
						m.push({r:r+d, c:c});
						if(((isW && r===6) || (!isW && r===1)) && !b[r + 2*d][c]){
							m.push({r:r + 2*d, c:c});
						}
					}
					for(let dc of [-1,1]){
						let nr = r + d, nc = c + dc;
						if(nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && b[nr][nc]){
							if(isW ? b[nr][nc] === b[nr][nc].toLowerCase() : b[nr][nc] === b[nr][nc].toUpperCase()){
								m.push({r:nr, c:nc});
							}
						}
					}
				}else if(dirs[p]){
					for(let [dr, dc] of dirs[p]){
						let nr = r + dr, nc = c + dc;
						while(nr >= 0 && nr < 8 && nc >= 0 && nc < 8){
							if(!b[nr][nc]){
								m.push({r: nr, c: nc});
							}else{
								if(isW ? b[nr][nc] === b[nr][nc].toLowerCase() : b[nr][nc] === b[nr][nc].toUpperCase()){
									m.push({r: nr, c: nc});
								}
								break;
							}
							if(p === 'n' || p === 'k'){
								break;
							}
							nr += dr;
							nc += dc;
						}
					}
				}
				if(includeCastling && p === 'k'){
					const row = isW ? 7 : 0;
					const kingId = isW ? 'K' : 'k';
					const opp = isW ? 'B' : 'W';
					if(!moved[kingId] && !isSquareAttacked(b, row, 4, opp)){
						if(!moved[`${isW?'R':'r'}_${row}_7`] && !b[row][5] && !b[row][6] && !isSquareAttacked(b, row, 5, opp)){
							m.push({r:row, c:6, castling:'K'});
						}
						if(!moved[`${isW?'R':'r'}_${row}_0`] && !b[row][1] && !b[row][2] && !b[row][3] && !isSquareAttacked(b, row, 3, opp)){
							m.push({r:row, c:2, castling:'Q'});
						}
					}
				}
				return m;
			}

			function getSafeMoves(r, c){
				const isW = board[r][c] === board[r][c].toUpperCase();
				return getRawMoves(board, r, c).filter(m => {
					const tmp = board.map(row => [...row]);
					tmp[m.r][m.c] = tmp[r][c];
					tmp[r][c] = '';
					const k = findKing(tmp, isW ? 'W' : 'B');
					return !isSquareAttacked(tmp, k.r, k.c, isW ? 'B' : 'W');
				});
			}

			function logMove(who, piece, to, captured, castling){
				const log = document.getElementById('moveLog');
				const coords = String.fromCharCode(97 + to.c) + (8 - to.r);
				let text = castling ? (castling === 'K' ? 'O-O' : 'O-O-O') : `${who}: ${piecesNames[piece]} to ${coords}`;
				if(captured && !castling){
					text += ` (captured ${piecesNames[captured]})`;
				}
				const div = document.createElement('div');
				div.className = 'log-entry';
				div.textContent = text;
				log.prepend(div);
			}

			function handleClick(r, c){
				if(turn === 'B'){
					return;
				}
				const move = legalMoves.find(m => m.r === r && m.c === c);
				if(move){
					executeMove(selected.r, selected.c, r, c, move.castling);
					return;
				}
				if(board[r][c] && board[r][c] === board[r][c].toUpperCase()){
					selected ={r, c};
					legalMoves = getSafeMoves(r, c);
				}else{
					selected = null;
					legalMoves = [];
				}
				drawBoard();
			}

			function executeMove(fR, fC, tR, tC, castlingType) {
				const p = board[fR][fC];
				const captured = board[tR][tC];
				if(castlingType === 'K'){
					board[tR][5] = board[tR][7]; board[tR][7] = '';
				}else if(castlingType === 'Q'){
					board[tR][3] = board[tR][0]; board[tR][0] = '';
				}
				if(p.toUpperCase() === 'K'){
					moved[p] = true;
				}
				if(p.toUpperCase() === 'R'){
					moved[`${p}_${fR}_${fC}`] = true;
				}
				logMove(turn === 'W' ? "White" : "Black", p, {r: tR, c: tC}, captured, castlingType);
				board[tR][tC] = p; board[fR][fC] = '';
				if(p === 'P' && tR === 0){
					board[tR][tC] = 'Q';
				}
				if(p === 'p' && tR === 7){
					board[tR][tC] = 'q';
				}
				lastMove = {fR, fC, tR, tC};
				selected = null;
				legalMoves = [];
				if(turn === 'W'){
					turn = 'B';
					document.getElementById('status').textContent = "Black is thinking...";
					drawBoard();
					setTimeout(pcMove, 800);
				}else{
					turn = 'W';
					document.getElementById('status').textContent = "White to move.";
					drawBoard();
				}
			}

			function pcMove() {
				let allMoves = [];
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						if(board[r][c] && board[r][c] === board[r][c].toLowerCase()){
							const moves = getSafeMoves(r, c);
							moves.forEach(m => allMoves.push({ fR: r, fC: c, tR: m.r, tC: m.c, castling: m.castling }));
						}
					}
				}
				if(allMoves.length === 0) {
					document.getElementById('status').textContent = "Game Over.";
					return;
				}
				const move = allMoves[Math.floor(Math.random()*allMoves.length)];
				executeMove(move.fR, move.fC, move.tR, move.tC, move.castling);
			}

			function toggleLog(){
				const logContainer = document.getElementById('logContainer');
				logContainer.style.display = document.getElementById('toggleLog').checked ? 'block' : 'none';
			}

			drawBoard();
		</script>
	</body>
</html>