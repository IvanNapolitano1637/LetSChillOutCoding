<!DOCTYPE html>
<html lang="en"><!--G07#019 - Filippo - Chess-->
	<head>
		<meta charset="UTF-8">
		<title>Chess</title>
		<style>
			:root{
				--bg: #2c3e50;
				--light: #f0d9b5;
				--dark: #b58863;
				--sel: #769656;
				--last-move: rgba(255, 255, 0, 0.4);
				--capture-flash: #e74c3c;
				--status-color: #f1c40f;
				--btn-color: #d35400;
			}
			body{
				font-family: 'Segoe UI', sans-serif;
				background: var(--bg);
				color: white;
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 20px;
			}
			.board{
				display: grid;
				grid-template-columns: repeat(8, 60px);
				grid-template-rows: repeat(8, 60px);
				border: 8px solid #34495e;
				box-shadow: 0 10px 30px rgba(0,0,0,0.5);
			}
			.square{
				width: 60px;
				height: 60px;
				display: flex;
				justify-content: center;
				align-items: center;
				font-size: 45px;
				cursor: pointer;
				user-select: none;
				position: relative;
				transition: background 0.2s;
			}
			.light{
				background-color: var(--light);
			}
			.dark{
				background-color: var(--dark);
			}
			.selected{
				background-color: var(--sel) !important;
			}
			.last-move{
				background-color: var(--last-move) !important;
			}
			.in-check{
				background-color: #e74c3c !important;
			}
			.legal-dot::after{
				content: '';
				width: 20px;
				height: 20px;
				background-color: #27ae60;
				border-radius: 50%;
				position: absolute;
				opacity: 0.8;
			}
			.capture-mark{
				background-color: rgba(39, 174, 96, 0.4) !important;
				border: 4px solid #27ae60;
				box-sizing: border-box;
			}
			.game-layout{
				display: flex;
				gap: 20px;
				align-items: flex-start;
				margin-top: 10px;
			}
			.info-panel{
				width: 250px;
				height: 496px;
				background: #34495e;
				padding: 15px;
				border-radius: 8px;
				text-align: left;
				overflow-y: auto;
				box-sizing: border-box;
				display: none;
			}
			.status{
				font-size: 1.2rem;
				margin-bottom: 15px;
				color: var(--status-color);
				font-weight: bold;
			}
			.log-entry{
				font-size: 0.9rem;
				border-bottom: 1px solid #456789;
				padding: 5px 0;
				color: #ecf0f1;
			}
			button{
				margin-top: 20px;
				padding: 10px 20px;
				cursor: pointer;
				background: var(--btn-color);
				color: white;
				border: none;
				border-radius: 5px;
				font-weight: bold;
				transition: opacity 0.2s;
			}
			button:hover{
				opacity: 0.9;
			}
			.difficulty-selector{
				margin-bottom: 15px;
			}
			.difficulty-selector select{
				padding: 5px 10px;
				font-size: 0.9rem;
				border-radius: 4px;
			}
		</style>
	</head>
	<body>
		<h1>Chess</h1>
		<div id="status" class="status">White to move.</div>
		<div class="difficulty-selector">
			<label for="difficulty">Difficulty: </label>
			<select id="difficulty">
				<option value="1">Easy</option>
				<option value="2">Medium</option>
				<option value="3" selected>Hard</option>
				<option value="4">Expert</option>
			</select>
		</div>
		<div style="margin-bottom: 15px;">
			<input type="checkbox" id="toggleLog" onclick="toggleLog()">
			<label for="toggleLog" style="cursor:pointer; font-size: 0.9rem;"> Show Log Moves</label>
		</div>
		<div class="game-layout">
			<div id="board" class="board"></div>
			<div class="info-panel" id="logContainer">
				<div style="font-weight: bold; border-bottom: 2px solid var(--status-color); margin-bottom: 10px;">LOG MOVES</div>
				<div id="moveLog"></div>
			</div>
		</div>
		<button onclick="location.reload()">Reset Game</button>

		<script>
			let board = [
				['r','n','b','q','k','b','n','r'],
				['p','p','p','p','p','p','p','p'],
				['','','','','','','',''], 
				['','','','','','','',''],
				['','','','','','','',''],
				['','','','','','','',''],
				['P','P','P','P','P','P','P','P'],
				['R','N','B','Q','K','B','N','R']
			];
			let moved = {'K': false, 'R_7_0': false, 'R_7_7': false, 'k': false, 'r_0_0': false, 'r_0_7': false};
			let enPassantTarget = null;
			const pieceValues = {'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000};
			const piecesNames = {'P':'Pawn', 'R':'Rook', 'N':'Knight', 'B':'Bishop', 'Q':'Queen', 'K':'King', 'p':'Pawn', 'r':'Rook', 'n':'Knight', 'b':'Bishop', 'q':'Queen', 'k':'King'};
			const pieces = {'p':'♟', 'r':'♜', 'n':'♞', 'b':'♝', 'q':'♛', 'k':'♚', 'P':'♙', 'R':'♖', 'N':'♘', 'B':'♗', 'Q':'♕', 'K':'♔'};
			let selected = null, legalMoves = [], turn = 'W', lastMove = null;
			const pawnTableWhite = [
				[0, 0, 0, 0, 0, 0, 0, 0],
				[50, 50, 50, 50, 50, 50, 50, 50],
				[10, 10, 20, 30, 30, 20, 10, 10],
				[5, 5, 10, 25, 25, 10, 5, 5],
				[0, 0, 0, 20, 20, 0, 0, 0],
				[5, -5, -10, 0, 0, -10, -5, 5],
				[5, 10, 10, -20, -20, 10, 10, 5],
				[0, 0, 0, 0, 0, 0, 0, 0]
			];
			const knightTable = [
				[-50, -40, -30, -30, -30, -30, -40, -50],
				[-40, -20, 0, 0, 0, 0, -20, -40],
				[-30, 0, 10, 15, 15, 10, 0, -30],
				[-30, 5, 15, 20, 20, 15, 5, -30],
				[-30, 0, 15, 20, 20, 15, 0, -30],
				[-30, 5, 10, 15, 15, 10, 5, -30],
				[-40, -20, 0, 5, 5, 0, -20, -40],
				[-50, -40, -30, -30, -30, -30, -40, -50]
			];
			const bishopTable = [
				[-20, -10, -10, -10, -10, -10, -10, -20],
				[-10, 0, 0, 0, 0, 0, 0, -10],
				[-10, 0, 5, 10, 10, 5, 0, -10],
				[-10, 5, 5, 10, 10, 5, 5, -10],
				[-10, 0, 10, 10, 10, 10, 0, -10],
				[-10, 10, 10, 10, 10, 10, 10, -10],
				[-10, 5, 0, 0, 0, 0, 5, -10],
				[-20, -10, -10, -10, -10, -10, -10, -20]
			];
			const rookTable = [
				[0, 0, 0, 0, 0, 0, 0, 0],
				[5, 10, 10, 10, 10, 10, 10, 5],
				[-5, 0, 0, 0, 0, 0, 0, -5],
				[-5, 0, 0, 0, 0, 0, 0, -5],
				[-5, 0, 0, 0, 0, 0, 0, -5],
				[-5, 0, 0, 0, 0, 0, 0, -5],
				[-5, 0, 0, 0, 0, 0, 0, -5],
				[0, 0, 0, 5, 5, 0, 0, 0]
			];
			const queenTable = [
				[-20, -10, -10, -5, -5, -10, -10, -20],
				[-10, 0, 0, 0, 0, 0, 0, -10],
				[-10, 0, 5, 5, 5, 5, 0, -10],
				[-5, 0, 5, 5, 5, 5, 0, -5],
				[0, 0, 5, 5, 5, 5, 0, -5],
				[-10, 5, 5, 5, 5, 5, 0, -10],
				[-10, 0, 5, 0, 0, 0, 0, -10],
				[-20, -10, -10, -5, -5, -10, -10, -20]
			];
			const kingTableMiddle = [
				[-30, -40, -40, -50, -50, -40, -40, -30],
				[-30, -40, -40, -50, -50, -40, -40, -30],
				[-30, -40, -40, -50, -50, -40, -40, -30],
				[-30, -40, -40, -50, -50, -40, -40, -30],
				[-20, -30, -30, -40, -40, -30, -30, -20],
				[-10, -20, -20, -20, -20, -20, -20, -10],
				[20, 20, 0, 0, 0, 0, 20, 20],
				[20, 30, 10, 0, 0, 10, 30, 20]
			];

			function drawBoard(){
				const boardEl = document.getElementById('board');
				boardEl.innerHTML = '';
				const currentKing = findKing(board, turn);
				const inCheck = (turn !== 'OVER') ? isSquareAttacked(board, currentKing.r, currentKing.c, turn === 'W' ? 'B' : 'W') : false;
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const sq = document.createElement('div');
						sq.className = `square ${(r + c)%2 === 0 ? 'light' : 'dark'}`;
						const p = board[r][c];
						if(p){
							sq.textContent = pieces[p];
							sq.style.color = p === p.toUpperCase() ? "white" : "black";
							if(p === p.toUpperCase()){
								sq.style.textShadow = "0 0 3px black";
							}
						}
						if(lastMove && ((lastMove.fR === r && lastMove.fC === c) || (lastMove.tR === r && lastMove.tC === c))){
							sq.classList.add('last-move');
						}
						if(selected && selected.r === r && selected.c === c){
							sq.classList.add('selected');
						}
						if(p && p.toUpperCase() === 'K' && (p === (turn === 'W' ? 'K' : 'k')) && inCheck){
							sq.classList.add('in-check');
						}
						const move = legalMoves.find(m => m.r === r && m.c === c);
						if(move){
							sq.classList.add((board[r][c] || move.enPassant) ? 'capture-mark' : 'legal-dot');
						}
						sq.onclick = () => handleClick(r, c);
						boardEl.appendChild(sq);
					}
				}
			}

			function findKing(b, color){
				const target = color === 'W' ? 'K' : 'k';
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						if(b[r][c] === target){
							return {r, c};
						}
					}
				}
				return {r:0, c:0};
			}

			function isSquareAttacked(b, row, col, attackerColor){
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const p = b[r][c];
						if(!p || (attackerColor === 'W' ? p !== p.toUpperCase() : p !== p.toLowerCase())){
							continue;
						}
						if(getRawMoves(b, r, c, false).some(m => m.r === row && m.c === col)){
							return true;
						}
					}
				}
				return false;
			}

			function getRawMoves(b, r, c, includeCastling = true){
				let m = [];
				const piece = b[r][c];
				const p = piece.toLowerCase();
				const isW = piece === piece.toUpperCase();
				const dirs ={'r': [[1,0],[-1,0],[0,1],[0,-1]], 'b': [[1,1],[1,-1],[-1,1],[-1,-1]], 'q': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], 'n': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]], 'k': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]};
				if(p === 'p'){
					let d = isW ? -1 : 1;
					if(r + d >= 0 && r + d < 8 && !b[r+d][c]){
						m.push({r: r+d, c: c});
						if(((isW && r===6) || (!isW && r===1)) && !b[r+2*d][c]){
							m.push({r: r+2*d, c: c});
						}
					}
					for(let dc of [-1,1]){
						let nr = r+d, nc = c+dc;
						if(nr >= 0 && nr < 8 && nc >= 0 && nc < 8){
							if(b[nr][nc] && (isW ? b[nr][nc] === b[nr][nc].toLowerCase() : b[nr][nc] === b[nr][nc].toUpperCase())){
								m.push({r: nr, c: nc});
							}
							if(!b[nr][nc] && enPassantTarget && enPassantTarget.r === nr && enPassantTarget.c === nc){
								m.push({r: nr, c: nc, enPassant: true});
							}
						}
					}
				}else if(dirs[p]){
					for(let [dr, dc] of dirs[p]){
						let nr = r + dr, nc = c + dc;
						while(nr >= 0 && nr < 8 && nc >= 0 && nc < 8){
							if(!b[nr][nc]){
								m.push({r: nr, c: nc});
							}else{
								if(isW ? b[nr][nc] === b[nr][nc].toLowerCase() : b[nr][nc] === b[nr][nc].toUpperCase()){
									m.push({r: nr, c: nc});
								}
								break;
							}
							if(p==='n' || p==='k'){
								break;
							}
							nr += dr;
							nc += dc;
						}
					}
				}
				if(includeCastling && p === 'k'){
					const row = isW ? 7 : 0;
					const opp = isW ? 'B' : 'W';
					if(!moved[piece] && !isSquareAttacked(b, r, c, opp)){
						const rk = isW ? 'R_7_7' : 'r_0_7';
						if(!moved[rk] && !b[row][5] && !b[row][6] && !isSquareAttacked(b, row, 5, opp) && !isSquareAttacked(b, row, 6, opp)){
							m.push({r: row, c: 6, castling: 'K'});
						}
						const rq = isW ? 'R_7_0' : 'r_0_0';
						if(!moved[rq] && !b[row][1] && !b[row][2] && !b[row][3] && !isSquareAttacked(b, row, 3, opp)){
							m.push({r: row, c: 2, castling: 'Q'});
						}
					}
				}
				return m;
			}

			function getSafeMoves(b, r, c){
				const isW = b[r][c] === b[r][c].toUpperCase();
				return getRawMoves(b, r, c).filter(m => {
					const tmp = b.map(row => [...row]);
					if(m.enPassant){
						tmp[r][m.c] = '';
					}
					if(m.castling === 'K'){
						tmp[isW ? 7 : 0][5] = tmp[isW ? 7 : 0][7];
						tmp[isW ? 7 : 0][7] = '';
					}else if(m.castling === 'Q'){
						tmp[isW ? 7 : 0][3] = tmp[isW ? 7 : 0][0];
						tmp[isW ? 7 : 0][0] = '';
					}
					tmp[m.r][m.c] = tmp[r][c];
					tmp[r][c] = '';
					const k = findKing(tmp, isW ? 'W' : 'B');
					return !isSquareAttacked(tmp, k.r, k.c, isW ? 'B' : 'W');
				});
			}

			function checkGameState(){
				let moves = [], piecesLeft = [];
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const p = board[r][c];
						if(p){
							piecesLeft.push(p.toLowerCase());
							if((turn === 'W' ? p === p.toUpperCase() : p === p.toLowerCase())){
								moves = moves.concat(getSafeMoves(board, r, c));
							}
						}
					}
				}
				const kPos = findKing(board, turn);
				const inCheck = isSquareAttacked(board, kPos.r, kPos.c, turn === 'W' ? 'B' : 'W');
				if(moves.length === 0){
					if(inCheck){
						document.getElementById('status').textContent = `CHECKMATE! ${turn === 'W' ? 'PC' : 'White'} wins!`;
					}else{
						document.getElementById('status').textContent = "STALEMATE! It's a draw.";
					}
					turn = 'OVER';
				}else if(piecesLeft.length <= 3){
					const nonKing = piecesLeft.filter(p => p !== 'k');
					if(nonKing.length === 0 || (nonKing.length === 1 && (nonKing[0] === 'b' || nonKing[0] === 'n'))){
						document.getElementById('status').textContent = "DRAW! Insufficient material.";
						turn = 'OVER';
					}
				}else{
					document.getElementById('status').textContent = `${turn === 'W' ? 'White' : 'PC'} to move ${inCheck ? '(CHECK!)' : ''}`;
				}
			}

			function executeMove(fR, fC, tR, tC, special){
				const p = board[fR][fC];
				let captured = board[tR][tC];
				if(special && special.enPassant){
					captured = board[fR][tC];
					board[fR][tC] = '';
				}
				if(special && special.castling === 'K'){
					board[tR][5] = board[tR][7];
					board[tR][7] = '';
				}else if(special && special.castling === 'Q'){
					board[tR][3] = board[tR][0];
					board[tR][0] = '';
				}
				if(p.toLowerCase() === 'p' && Math.abs(tR - fR) === 2){
					enPassantTarget = {r: (fR + tR) / 2, c: fC};
				}else{
					enPassantTarget = null;
				}
				if(p.toUpperCase() === 'K'){
					moved[p] = true;
				}
				if(p.toUpperCase() === 'R'){
					moved[`${p}_${fR}_${fC}`] = true;
				}
				logMove(turn === 'W' ? "White" : "PC", p, {r: tR, c: tC}, captured, special);
				board[tR][tC] = p;
				board[fR][fC] = '';
				if(p === 'P' && tR === 0){
					board[tR][tC] = 'Q';
				}
				if(p === 'p' && tR === 7){
					board[tR][tC] = 'q';
				}
				lastMove = {fR, fC, tR, tC};
				selected = null;
				legalMoves = [];
				turn = (turn === 'W') ? 'B' : 'W';
				checkGameState();
				drawBoard();
				if(turn === 'B'){
					document.getElementById('status').textContent = "Black to move. Wait.";
					setTimeout(pcMove, 600);
				}
			}

			function evaluateBoard(b, forBlack = true){
				let score = 0;
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const p = b[r][c];
						if(!p){
							continue;
						}
						const isBlackPiece = p === p.toLowerCase();
						const type = p.toLowerCase();
						let value = pieceValues[type];
						let posBonus = 0;
						if(type === 'p'){
							posBonus = isBlackPiece ? pawnTableWhite[r][c] : pawnTableWhite[7 - r][c];
						}else if(type === 'n'){
							posBonus = isBlackPiece ? knightTable[r][c] : knightTable[7 - r][c];
						}else if(type === 'b'){
							posBonus = isBlackPiece ? bishopTable[r][c] : bishopTable[7 - r][c];
						}else if(type === 'r'){
							posBonus = isBlackPiece ? rookTable[r][c] : rookTable[7 - r][c];
						}else if(type === 'q'){
							posBonus = isBlackPiece ? queenTable[r][c] : queenTable[7 - r][c];
						}else if(type === 'k'){
							posBonus = isBlackPiece ? kingTableMiddle[r][c] : kingTableMiddle[7 - r][c];
						}
						value += posBonus;
						score += isBlackPiece ? value : -value;
					}
				}
				const whiteKing = findKing(b, 'W');
				const blackKing = findKing(b, 'B');
				if(isSquareAttacked(b, whiteKing.r, whiteKing.c, 'B')){
					score += 50;
				}
				if(isSquareAttacked(b, blackKing.r, blackKing.c, 'W')){
					score -= 50;
				}
				return forBlack ? score : -score;
			}

			function minimax(b, depth, alpha, beta, maximizing){
				if(depth === 0){
					return evaluateBoard(b, true);
				}
				const color = maximizing ? 'B' : 'W';
				let allMoves = [];
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const p = b[r][c];
						if(!p){
							continue;
						}
						if(maximizing ? (p !== p.toLowerCase()) : (p !== p.toUpperCase())){
							continue;
						}
						const moves = getSafeMoves(b, r, c);
						moves.forEach(m => {
							allMoves.push({fR: r, fC: c, tR: m.r, tC: m.c, special: m});
						});
					}
				}
				if(allMoves.length === 0){
					const king = findKing(b, color);
					if(isSquareAttacked(b, king.r, king.c, color === 'W' ? 'B' : 'W')){
						return maximizing ? -50000 : 50000;
					}
					return 0;
				}
				if(maximizing){
					let maxEval = -Infinity;
					for(const move of allMoves){
						const tmp = b.map(row => [...row]);
						if(move.special && move.special.enPassant){
							tmp[move.fR][move.tC] = '';
						}
						if(move.special && move.special.castling === 'K'){ 
							tmp[move.tR][5] = tmp[move.tR][7];
							tmp[move.tR][7] = '';
						}else if(move.special && move.special.castling === 'Q'){ 
							tmp[move.tR][3] = tmp[move.tR][0];
							tmp[move.tR][0] = '';
						}
						tmp[move.tR][move.tC] = tmp[move.fR][move.fC];
						tmp[move.fR][move.fC] = '';
						const eval = minimax(tmp, depth - 1, alpha, beta, false);
						maxEval = Math.max(maxEval, eval);
						alpha = Math.max(alpha, eval);
						if(beta <= alpha){
							break;
						}
					}
					return maxEval;
				}else{
					let minEval = Infinity;
					for(const move of allMoves){
						const tmp = b.map(row => [...row]);
						if(move.special && move.special.enPassant){
							tmp[move.fR][move.tC] = '';
						}
						if(move.special && move.special.castling === 'K'){ 
							tmp[move.tR][5] = tmp[move.tR][7];
							tmp[move.tR][7] = '';
						}else if(move.special && move.special.castling === 'Q'){ 
							tmp[move.tR][3] = tmp[move.tR][0];
							tmp[move.tR][0] = '';
						}
						tmp[move.tR][move.tC] = tmp[move.fR][move.fC];
						tmp[move.fR][move.fC] = '';
						const eval = minimax(tmp, depth - 1, alpha, beta, true);
						minEval = Math.min(minEval, eval);
						beta = Math.min(beta, eval);
						if(beta <= alpha){
							break;
						}
					}
					return minEval;
				}
			}

			function pcMove(){
				if(turn !== 'B'){
					return;
				}
				const depth = parseInt(document.getElementById('difficulty').value);
				let allMoves = [];
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						if(board[r][c] && board[r][c] === board[r][c].toLowerCase()){
							const moves = getSafeMoves(board, r, c);
							moves.forEach(m => {
								allMoves.push({ fR: r, fC: c, tR: m.r, tC: m.c, special: m });
							});
						}
					}
				}
				if(allMoves.length === 0){
					return;
				}
				let bestMove = null;
				let bestValue = -Infinity;
				for(const move of allMoves){
					const tmp = board.map(row => [...row]);
					const oldEnPassant = enPassantTarget;
					if(move.special && move.special.enPassant){
						tmp[move.fR][move.tC] = '';
					}
					if(move.special && move.special.castling === 'K'){ 
						tmp[move.tR][5] = tmp[move.tR][7];
						tmp[move.tR][7] = '';
					}else if(move.special && move.special.castling === 'Q'){ 
						tmp[move.tR][3] = tmp[move.tR][0];
						tmp[move.tR][0] = '';
					}
					tmp[move.tR][move.tC] = tmp[move.fR][move.fC];
					tmp[move.fR][move.fC] = '';
					const moveValue = minimax(tmp, depth - 1, -Infinity, Infinity, false);
					enPassantTarget = oldEnPassant;
					if(moveValue > bestValue){
						bestValue = moveValue;
						bestMove = move;
					}
				}
				if(bestMove){
					executeMove(bestMove.fR, bestMove.fC, bestMove.tR, bestMove.tC, bestMove.special);
				}
			}

			function handleClick(r, c){
				if(turn !== 'W'){
					return;
				}
				const move = legalMoves.find(m => m.r === r && m.c === c);
				if(move){
					executeMove(selected.r, selected.c, r, c, move);
					return;
				}
				if(board[r][c] && board[r][c] === board[r][c].toUpperCase()){
					selected = {r, c};
					legalMoves = getSafeMoves(board, r, c);
				}else{
					selected = null;
					legalMoves = [];
				}
				drawBoard();
			}

			function logMove(who, piece, to, captured, special){
				const log = document.getElementById('moveLog');
				const coords = String.fromCharCode(97 + to.c) + (8 - to.r);
				let text = (special && special.castling) ? (special.castling === 'K' ? 'O-O' : 'O-O-O') : `${who}: ${piecesNames[piece]} to ${coords}`;
				if(captured){
					text += ` (captured ${piecesNames[captured.toLowerCase().toUpperCase()]})`;
				}
				const div = document.createElement('div');
				div.className = 'log-entry';
				div.textContent = text;
				log.prepend(div);
			}

			function toggleLog(){
				document.getElementById('logContainer').style.display = document.getElementById('toggleLog').checked ? 'block' : 'none';
			}

			drawBoard();
		</script>
	</body>
</html>