<!DOCTYPE html>
<html lang="en"><!--G07#019 - Filippo - Chess-->
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Chess</title>
		<style>
			:root{
				--bg: #2c3e50;
				--light: #f0d9b5;
				--dark: #b58863;
				--sel: #769656;
				--last-move: rgba(255, 255, 0, 0.4);
				--status-color: #f1c40f;
				--sq-size: clamp(35px, 10vw, 60px);
			}
			body{
				font-family: 'Segoe UI', sans-serif;
				background: var(--bg);
				color: white;
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 10px;
				margin: 0;
				min-height: 100vh;
			}
			.game-layout{
				display: flex;
				flex-wrap: wrap;
				gap: 20px;
				justify-content: center;
				align-items: flex-start;
				margin-top: 10px;
				width: 100%;
				max-width: 1000px;
			}
			.board{
				display: grid;
				grid-template-columns: repeat(8, var(--sq-size));
				grid-template-rows: repeat(8, var(--sq-size));
				border: 4px solid #34495e;
				box-shadow: 0 10px 30px rgba(0,0,0,0.5);
				user-select: none;
			}
			.square{
				width: var(--sq-size);
				height: var(--sq-size);
				display: flex;
				justify-content: center;
				align-items: center;
				font-size: calc(var(--sq-size)*0.75);
				cursor: pointer;
				position: relative;
				transition: background 0.2s;
			}
			.light{
				background-color: var(--light);
			}
			.dark{
				background-color: var(--dark);
			}
			.selected{
				background-color: var(--sel) !important;
			}
			.last-move{
				background-color: var(--last-move) !important;
			}
			.in-check{
				background-color: #e74c3c !important;
			}
			.legal-dot::after{
				content: '';
				width: 30%;
				height: 30%;
				background-color: #27ae60;
				border-radius: 50%;
				position: absolute;
				opacity: 0.8;
			}
			.capture-mark{
				background-color: rgba(39, 174, 96, 0.4) !important;
				border: calc(var(--sq-size)*0.05) solid #27ae60;
				box-sizing: border-box;
			}
			.info-panel{
				width: 250px;
				height: calc(8*var(--sq-size));
				background: #34495e;
				padding: 15px;
				border-radius: 8px;
				overflow-y: auto;
				box-sizing: border-box;
				display: none;
			}
			.controls{
				display: flex;
				flex-direction: column;
				gap: 10px;
				margin: 20px 0;
				width: 100%;
				max-width: 500px;
			}
			.row-1{
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 10px;
			}
			.row-2{
				display: grid;
				grid-template-columns: 1fr 1fr 1fr;
				gap: 10px;
			}
			.controls button{
				padding: 12px 2px;
				cursor: pointer;
				color: white;
				border: none;
				border-radius: 6px;
				font-weight: bold;
				font-size: 0.8rem;
				transition: all 0.3s ease;
				box-shadow: 0 4px 6px rgba(0,0,0,0.2);
			}
			button:active:not(.no-click){
				transform: scale(0.98);
			}
			.no-click{
				cursor: default !important;
			}
			.log-entry{
				font-size: 0.85rem;
				border-bottom: 1px solid #456789;
				padding: 6px 0;
				color: #ecf0f1;
			}
			@media (max-width: 600px){
				.info-panel{
					width: 100%;
					height: 200px;
				}
				.square{
					font-size: calc(var(--sq-size)*0.85);
				}
			}
		</style>
	</head>
	<body>
		<div class="game-layout">
			<div id="board" class="board"></div>
			<div class="info-panel" id="logContainer">
				<div style="font-weight: bold; border-bottom: 2px solid var(--status-color); margin-bottom: 10px; color: var(--status-color);">LOG MOVES</div>
				<div id="moveLog"></div>
			</div>
		</div>		
		<div class="controls">
			<div class="row-1">
				<button id="statusBtn" class="no-click" style="background: white; color: black;">White to move</button>
				<button id="diffBtn" onclick="cycleDifficulty()" style="background: #c0392b;">Level: Hard</button>
			</div>
			<div class="row-2">
				<button id="toggleLogBtn" onclick="toggleLog()" style="background: #3498db;">Show Log</button>
				<button id="undoBtn" onclick="undoMove()" style="background: #95a5a6;">Undo</button>
				<button onclick="location.reload()" style="background: #e67e22;">Reset</button>
			</div>
		</div>
		<script>
			let board = [['r','n','b','q','k','b','n','r'],['p','p','p','p','p','p','p','p'],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['P','P','P','P','P','P','P','P'],['R','N','B','Q','K','B','N','R']];
			let moved = {'K': false, 'k': false, 'R_7_0': false, 'R_7_7': false, 'r_0_0': false, 'r_0_7': false};
			let enPassantTarget = null;
			let history = [];
			const pieceValues = {'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000};
			const piecesNames = {'P':'Pawn', 'R':'Rook', 'N':'Knight', 'B':'Bishop', 'Q':'Queen', 'K':'King', 'p':'Pawn', 'r':'Rook', 'n':'Knight', 'b':'Bishop', 'q':'Queen', 'k':'King'};
			const pieces = {'p':'♟', 'r':'♜', 'n':'♞', 'b':'♝', 'q':'♛', 'k':'♚', 'P':'♙', 'R':'♖', 'N':'♘', 'B':'♗', 'Q':'♕', 'K':'♔'};
			let selected = null, legalMoves = [], turn = 'W', lastMove = null;
			const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
			const levels = [{name: 'Easy', val: 1, color: '#27ae60'}, {name: 'Medium', val: 2, color: '#2980b9'}, {name: 'Hard', val: 3, color: '#c0392b'}, {name: 'Expert', val: 4, color: '#8e44ad'}];
			let currentDiffIdx = 2;
			const pawnTableWhite = [[0, 0, 0, 0, 0, 0, 0, 0],[50, 50, 50, 50, 50, 50, 50, 50],[10, 10, 20, 30, 30, 20, 10, 10],[5, 5, 10, 25, 25, 10, 5, 5],[0, 0, 0, 20, 20, 0, 0, 0],[5, -5, -10, 0, 0, -10, -5, 5],[5, 10, 10, -20, -20, 10, 10, 5],[0, 0, 0, 0, 0, 0, 0, 0]];
			const knightTable = [[-50, -40, -30, -30, -30, -30, -40, -50],[-40, -20, 0, 0, 0, 0, -20, -40],[-30, 0, 10, 15, 15, 10, 0, -30],[-30, 5, 15, 20, 20, 15, 5, -30],[-30, 0, 15, 20, 20, 15, 0, -30],[-30, 5, 10, 15, 15, 10, 5, -30],[-40, -20, 0, 5, 5, 0, -20, -40],[-50, -40, -30, -30, -30, -30, -40, -50]];
			const bishopTable = [[-20, -10, -10, -10, -10, -10, -10, -20],[-10, 0, 0, 0, 0, 0, 0, -10],[-10, 0, 5, 10, 10, 5, 0, -10],[-10, 5, 5, 10, 10, 5, 5, -10],[-10, 0, 10, 10, 10, 10, 0, -10],[-10, 10, 10, 10, 10, 10, 10, -10],[-10, 5, 0, 0, 0, 0, 5, -10],[-20, -10, -10, -10, -10, -10, -10, -20]];
			const rookTable = [[0, 0, 0, 0, 0, 0, 0, 0],[5, 10, 10, 10, 10, 10, 10, 5],[-5, 0, 0, 0, 0, 0, 0, -5],[-5, 0, 0, 0, 0, 0, 0, -5],[-5, 0, 0, 0, 0, 0, 0, -5],[-5, 0, 0, 0, 0, 0, 0, -5],[-5, 0, 0, 0, 0, 0, 0, -5],[0, 0, 0, 5, 5, 0, 0, 0]];
			const queenTable = [[-20, -10, -10, -5, -5, -10, -10, -20],[-10, 0, 0, 0, 0, 0, 0, -10],[-10, 0, 5, 5, 5, 5, 0, -10],[-5, 0, 5, 5, 5, 5, 0, -5],[0, 0, 5, 5, 5, 5, 0, -5],[-10, 5, 5, 5, 5, 5, 0, -10],[-10, 0, 5, 0, 0, 0, 0, -10],[-20, -10, -10, -5, -5, -10, -10, -20]];
			const kingTableMiddle = [[-30, -40, -40, -50, -50, -40, -40, -30],[-30, -40, -40, -50, -50, -40, -40, -30],[-30, -40, -40, -50, -50, -40, -40, -30],[-30, -40, -40, -50, -50, -40, -40, -30],[-20, -30, -30, -40, -40, -30, -30, -20],[-10, -20, -20, -20, -20, -20, -20, -10],[20, 20, 0, 0, 0, 0, 20, 20],[20, 30, 10, 0, 0, 10, 30, 20]];

			function playSound(type){
				const osc = audioCtx.createOscillator();
				const gain = audioCtx.createGain();
				osc.connect(gain);
				gain.connect(audioCtx.destination);
				const now = audioCtx.currentTime;
				if(type === 'capture'){
					osc.type = 'square';
					osc.frequency.setValueAtTime(150, now);
					osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
					gain.gain.setValueAtTime(0.1, now);
					gain.gain.linearRampToValueAtTime(0, now + 0.1);
					osc.start();
					osc.stop(now + 0.1);
				}else if(type === 'check'){
					osc.type = 'sine';
					osc.frequency.setValueAtTime(440, now);
					osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
					gain.gain.setValueAtTime(0.1, now);
					gain.gain.linearRampToValueAtTime(0, now + 0.2);
					osc.start();
					osc.stop(now + 0.2);
				}else if(type === 'mate'){
					osc.type = 'sawtooth';
					osc.frequency.setValueAtTime(200, now);
					osc.frequency.linearRampToValueAtTime(100, now + 0.5);
					gain.gain.setValueAtTime(0.2, now);
					gain.gain.linearRampToValueAtTime(0, now + 0.5);
					osc.start();
					osc.stop(now + 0.5);
				}else if(type === 'draw'){
					osc.type = 'triangle';
					osc.frequency.setValueAtTime(300, now);
					gain.gain.setValueAtTime(0.1, now);
					gain.gain.linearRampToValueAtTime(0, now + 0.3);
					osc.start();osc.stop(now + 0.3);
				}
			}

			function cycleDifficulty(){
				currentDiffIdx = (currentDiffIdx + 1)%levels.length;
				const btn = document.getElementById('diffBtn');
				btn.textContent = `Level: ${levels[currentDiffIdx].name}`;
				btn.style.background = levels[currentDiffIdx].color;
			}

			function toggleLog(){
				const container = document.getElementById('logContainer');
				const btn = document.getElementById('toggleLogBtn');
				container.style.display = (container.style.display === 'block') ? 'none' : 'block';
				btn.textContent = container.style.display === 'block' ? "Hide Log" : "Show Log";
			}

			function drawBoard(){
				const boardEl = document.getElementById('board');
				boardEl.innerHTML = '';
				const currentKing = findKing(board, turn);
				const inCheck = (turn !== 'OVER') ? isSquareAttacked(board, currentKing.r, currentKing.c, turn === 'W' ? 'B' : 'W') : false;
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const sq = document.createElement('div');
						sq.className = `square ${(r + c)%2 === 0 ? 'light' : 'dark'}`;
						const p = board[r][c];
						if(p){
							sq.textContent = pieces[p];
							sq.style.color = p === p.toUpperCase() ? "white" : "black";
							if(p === p.toUpperCase()){
								sq.style.textShadow = "0 0 3px black";
							}
						}
						if(lastMove && ((lastMove.fR === r && lastMove.fC === c) || (lastMove.tR === r && lastMove.tC === c))){
							sq.classList.add('last-move');
						}
						if(selected && selected.r === r && selected.c === c){
							sq.classList.add('selected');
						}
						if(p && p.toUpperCase() === 'K' && (p === (turn === 'W' ? 'K' : 'k')) && inCheck){
							sq.classList.add('in-check');
						}
						const move = legalMoves.find(m => m.r === r && m.c === c);
						if(move){
							sq.classList.add((board[r][c] || move.enPassant) ? 'capture-mark' : 'legal-dot');
						}
						sq.onclick = () => handleClick(r, c);
						boardEl.appendChild(sq);
					}
				}
			}

			function findKing(b, color){
				const target = color === 'W' ? 'K' : 'k';
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						if(b[r][c] === target){
							return {r, c};
						}
					}
				}
				return {r:0, c:0};
			}

			function isSquareAttacked(b, row, col, attackerColor){
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const p = b[r][c];
						if(!p || (attackerColor === 'W' ? p !== p.toUpperCase() : p !== p.toLowerCase())){
							continue;
						}
						if(getRawMoves(b, r, c, false).some(m => m.r === row && m.c === col)){
							return true;
						}
					}
				}
				return false;
			}

			function getRawMoves(b, r, c, includeCastling = true){
				let m = [];
				const piece = b[r][c];
				const p = piece.toLowerCase();
				const isW = piece === piece.toUpperCase();
				const dirs = {'r': [[1,0],[-1,0],[0,1],[0,-1]], 'b': [[1,1],[1,-1],[-1,1],[-1,-1]], 'q': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], 'n': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]], 'k': [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]};
				if(p === 'p'){
					let d = isW ? -1 : 1;
					if(r + d >= 0 && r + d < 8 && !b[r + d][c]){
						m.push({r: r + d, c: c});
						if(((isW && r===6) || (!isW && r===1)) && !b[r + 2*d][c]){
							m.push({r: r + 2*d, c: c});
						}
					}
					for(let dc of [-1,1]){
						let nr = r + d, nc = c + dc;
						if(nr >= 0 && nr < 8 && nc >= 0 && nc < 8){
							if(b[nr][nc] && (isW ? b[nr][nc] === b[nr][nc].toLowerCase() : b[nr][nc] === b[nr][nc].toUpperCase())){
								m.push({r: nr, c: nc});
							}
							if(!b[nr][nc] && enPassantTarget && enPassantTarget.r === nr && enPassantTarget.c === nc){
								m.push({r: nr, c: nc, enPassant: true});
							}
						}
					}
				}else if(dirs[p]){
					for(let [dr, dc] of dirs[p]){
						let nr = r + dr, nc = c + dc;
						while(nr >= 0 && nr < 8 && nc >= 0 && nc < 8){
							if(!b[nr][nc]){
								m.push({r: nr, c: nc});
							}else{
								if(isW ? b[nr][nc] === b[nr][nc].toLowerCase() : b[nr][nc] === b[nr][nc].toUpperCase()){
									m.push({r: nr, c: nc});
								}
								break;
							}
							if(p==='n' || p==='k'){
								break;
							}
							nr += dr;
							nc += dc;
						}
					}
				}
				if(includeCastling && p === 'k'){
					const row = isW ? 7 : 0;
					const opp = isW ? 'B' : 'W';
					if(!moved[piece] && !isSquareAttacked(b, r, c, opp)){
						const rk = isW ? 'R_7_7' : 'r_0_7';
						if(!moved[rk] && !b[row][5] && !b[row][6] && !isSquareAttacked(b, row, 5, opp) && !isSquareAttacked(b, row, 6, opp)){
							m.push({r: row, c: 6, castling: 'K'});
						}
						const rq = isW ? 'R_7_0' : 'r_0_0';
						if(!moved[rq] && !b[row][1] && !b[row][2] && !b[row][3] && !isSquareAttacked(b, row, 3, opp)){
							m.push({r: row, c: 2, castling: 'Q'});
						}
					}
				}
				return m;
			}

			function getSafeMoves(b, r, c){
				const isW = b[r][c] === b[r][c].toUpperCase();
				return getRawMoves(b, r, c).filter(m => {
					const tmp = b.map(row => [...row]);
					if(m.enPassant){
						tmp[r][m.c] = '';
					}
					if(m.castling === 'K'){
						tmp[isW ? 7 : 0][5] = tmp[isW ? 7 : 0][7];
						tmp[isW ? 7 : 0][7] = '';
					}else if(m.castling === 'Q'){
						tmp[isW ? 7 : 0][3] = tmp[isW ? 7 : 0][0];
						tmp[isW ? 7 : 0][0] = '';
					}
					tmp[m.r][m.c] = tmp[r][c];
					tmp[r][c] = '';
					const k = findKing(tmp, isW ? 'W' : 'B');
					return !isSquareAttacked(tmp, k.r, k.c, isW ? 'B' : 'W');
				});
			}

			function checkGameState(){
				let moves = [], piecesLeft = [];
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const p = board[r][c];
						if(p){
							piecesLeft.push(p.toLowerCase());
							if((turn === 'W' ? p === p.toUpperCase() : p === p.toLowerCase())){
								moves = moves.concat(getSafeMoves(board, r, c));
							}
						}
					}
				}
				const kPos = findKing(board, turn);
				const inCheck = isSquareAttacked(board, kPos.r, kPos.c, turn === 'W' ? 'B' : 'W');
				const statusBtn = document.getElementById('statusBtn');
				if(moves.length === 0){
					if(inCheck){
						playSound('mate');
						statusBtn.textContent = `CHECKMATE! ${turn === 'W' ? 'Black' : 'White'} wins!`;
					}else{
						playSound('draw');statusBtn.textContent = "STALEMATE! It's a draw.";
					}
					statusBtn.style.background = "#e74c3c";
					statusBtn.style.color = "white";
					turn = 'OVER';
				}else if(piecesLeft.length <= 3){
					const nonKing = piecesLeft.filter(p => p !== 'k');
					if(nonKing.length === 0 || (nonKing.length === 1 && (nonKing[0] === 'b' || nonKing[0] === 'n'))){
						playSound('draw');
						statusBtn.textContent = "DRAW! Insufficient material.";
						statusBtn.style.background = "#e74c3c";
						statusBtn.style.color = "white";
						turn = 'OVER';
					}
				}else{
					if(inCheck){
						playSound('check');
					}
					statusBtn.textContent = `${turn === 'W' ? 'White' : 'Black'} to move.${inCheck ? ' (+)' : ''}`;
					statusBtn.style.background = (turn === 'W' ? "white" : "black");
					statusBtn.style.color = (turn === 'W' ? "black" : "white");
				}
			}

			function executeMove(fR, fC, tR, tC, special){
				if(turn === 'W'){
					history.push({
						board: board.map(row => [...row]),
						moved:{...moved},
						enPassantTarget: enPassantTarget ? {...enPassantTarget} : null,
						lastMove: lastMove ? {...lastMove} : null,
						logCount: document.getElementById('moveLog').children.length
					});
				}
				const p = board[fR][fC];
				if(fR === 7 && fC === 0){
					moved['R_7_0'] = true;
				}
				if(fR === 7 && fC === 7){
					moved['R_7_7'] = true;
				}
				if(fR === 0 && fC === 0){
					moved['r_0_0'] = true;
				}
				if(fR === 0 && fC === 7){
					moved['r_0_7'] = true;
				}
				let captured = board[tR][tC];
				if(special && special.enPassant){
					captured = board[fR][tC];
					board[fR][tC] = '';
				}
				if(captured){
					playSound('capture');
				}
				if(special && special.castling === 'K'){
					board[tR][5] = board[tR][7];
					board[tR][7] = '';
				}else if(special && special.castling === 'Q'){
					board[tR][3] = board[tR][0];
					board[tR][0] = '';
				}
				if(p.toLowerCase() === 'p' && Math.abs(tR - fR) === 2){
					enPassantTarget = {r: (fR + tR)/2, c: fC};
				}else{
					enPassantTarget = null;
				}
				if(p.toUpperCase() === 'K'){
					moved[p] = true;
				}
				logMove(turn === 'W' ? "White" : "Black", p, {r: tR, c: tC}, captured, special);
				board[tR][tC] = p;
				board[fR][fC] = '';
				if(p === 'P' && tR === 0){
					board[tR][tC] = 'Q';
				}
				if(p === 'p' && tR === 7){
					board[tR][tC] = 'q';
				}
				lastMove = {fR, fC, tR, tC};
				selected = null;
				legalMoves = [];
				turn = (turn === 'W') ? 'B' : 'W';
				checkGameState();
				drawBoard();
				if(turn === 'B'){
					setTimeout(pcMove, 600);
				}
			}

			function undoMove(){
				if(turn !== 'W' || history.length === 0){
					return;
				}
				const lastState = history.pop();
				board = lastState.board;
				moved = lastState.moved;
				enPassantTarget = lastState.enPassantTarget;
				lastMove = lastState.lastMove;
				const log = document.getElementById('moveLog');
				while(log.children.length > lastState.logCount){
					log.removeChild(log.firstChild);
				}
				turn = 'W';
				selected = null;
				legalMoves = [];
				checkGameState();
				drawBoard();
			}

			function evaluateBoard(b, forBlack = true){
				let score = 0;
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const p = b[r][c];
						if(!p){
							continue;
						}
						const isBlackPiece = p === p.toLowerCase();
						const type = p.toLowerCase();
						let value = pieceValues[type];
						let posBonus = 0;
						if(type === 'p'){
							posBonus = isBlackPiece ? pawnTableWhite[r][c] : pawnTableWhite[7 - r][c];
						}else if(type === 'n'){
							posBonus = isBlackPiece ? knightTable[r][c] : knightTable[7 - r][c];
						}else if(type === 'b'){
							posBonus = isBlackPiece ? bishopTable[r][c] : bishopTable[7 - r][c];
						}else if(type === 'r'){
							posBonus = isBlackPiece ? rookTable[r][c] : rookTable[7 - r][c];
						}else if(type === 'q'){
							posBonus = isBlackPiece ? queenTable[r][c] : queenTable[7 - r][c];
						}else if(type === 'k'){
							posBonus = isBlackPiece ? kingTableMiddle[r][c] : kingTableMiddle[7 - r][c];
						}
						value += posBonus;
						score += isBlackPiece ? value : -value;
					}
				}
				return forBlack ? score : -score;
			}

			function minimax(b, depth, alpha, beta, maximizing){
				if(depth === 0){
					return evaluateBoard(b, true);
				}
				const color = maximizing ? 'B' : 'W';
				let allMoves = [];
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						const p = b[r][c];
						if(!p || (maximizing ? (p !== p.toLowerCase()) : (p !== p.toUpperCase()))){
							continue;
						}
						getSafeMoves(b, r, c).forEach(m => allMoves.push({fR: r, fC: c, tR: m.r, tC: m.c, special: m}));
					}
				}
				if(allMoves.length === 0){
					const king = findKing(b, color);
					if(isSquareAttacked(b, king.r, king.c, color === 'W' ? 'B' : 'W')){
						return maximizing ? -50000 : 50000;
					}
					return 0;
				}
				if(maximizing){
					let maxEval = -Infinity;
					for(const move of allMoves){
						const tmp = b.map(row => [...row]);
						tmp[move.tR][move.tC] = tmp[move.fR][move.fC];
						tmp[move.fR][move.fC] = '';
						const eval = minimax(tmp, depth - 1, alpha, beta, false);
						maxEval = Math.max(maxEval, eval);
						alpha = Math.max(alpha, eval);
						if(beta <= alpha){
							break;
						}
					}
					return maxEval;
				}else{
					let minEval = Infinity;
					for(const move of allMoves){
						const tmp = b.map(row => [...row]);
						tmp[move.tR][move.tC] = tmp[move.fR][move.fC];
						tmp[move.fR][move.fC] = '';
						const eval = minimax(tmp, depth - 1, alpha, beta, true);
						minEval = Math.min(minEval, eval);
						beta = Math.min(beta, eval);
						if(beta <= alpha){
							break;
						}
					}
					return minEval;
				}
			}

			function pcMove(){
				if(turn !== 'B'){
					return;
				}
				const depth = levels[currentDiffIdx].val;
				let allMoves = [];
				for(let r = 0; r < 8; r++){
					for(let c = 0; c < 8; c++){
						if(board[r][c] && board[r][c] === board[r][c].toLowerCase()){
							getSafeMoves(board, r, c).forEach(m => allMoves.push({fR: r, fC: c, tR: m.r, tC: m.c, special: m }));
						}
					}
				}
				if(allMoves.length === 0){
					return;
				}
				let bestMove = null, bestValue = -Infinity;
				for(const m of allMoves){
					const tmp = board.map(row => [...row]);
					tmp[m.tR][m.tC] = tmp[m.fR][m.fC];
					tmp[m.fR][m.fC] = '';
					let v = minimax(tmp, depth - 1, -Infinity, Infinity, false);
					if(v > bestValue){
						bestValue = v;
						bestMove = m;
					}
				}
				if(bestMove){
					executeMove(bestMove.fR, bestMove.fC, bestMove.tR, bestMove.tC, bestMove.special);
				}
			}

			function handleClick(r, c){
				if(audioCtx.state === 'suspended'){
					audioCtx.resume();
				}
				if(turn !== 'W'){
					return;
				}
				const move = legalMoves.find(m => m.r === r && m.c === c);
				if(move){
					executeMove(selected.r, selected.c, r, c, move);
					return;
				}
				if(selected && selected.r === r && selected.c === c){
					selected = null;
					legalMoves = [];
				}else if(board[r][c] && board[r][c] === board[r][c].toUpperCase()){
					selected = {r, c};
					legalMoves = getSafeMoves(board, r, c);
				}else{
					selected = null;
					legalMoves = [];
				}
				drawBoard();
			}

			function logMove(who, piece, to, captured, special){
				const log = document.getElementById('moveLog');
				const coords = String.fromCharCode(97 + to.c) + (8 - to.r);
				let text = (special && special.castling) ? (special.castling === 'K' ? 'O-O' : 'O-O-O') : `${who}: ${piecesNames[piece]} ${coords}`;
				if(captured){
					text += ' (x)';
				}
				let div = document.createElement('div');
				div.className = 'log-entry';
				div.textContent = text;
				log.prepend(div);
			}

			drawBoard();
		</script>
	</body>
</html>